<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Flux-Point Protocol</title>
    <style>
        body { margin: 0; background: #0a0e14; color: #00f2ff; font-family: 'Segoe UI', Roboto, sans-serif; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        canvas { display: block; touch-action: none; }
        .stat-box { background: rgba(0, 242, 255, 0.1); border-left: 4px solid #00f2ff; padding: 10px 15px; }
        .label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.8; }
        .value { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #instruction { margin-top: 10px; font-size: 14px; color: #fff; opacity: 0.6; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat-box">
            <div class="label">Neon-Flux</div>
            <div class="value" id="flux-count">0</div>
        </div>
        <div id="instruction">Select Sentinel, then tap Flux-Point to capture</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fluxEl = document.getElementById('flux-count');

        let flux = 0;
        let activeSentinel = null;
        
        // Map Nodes (The Capture Points)
        const nodes = [
            { x: 0.5, y: 0.25, radius: 45, state: 'neutral', pulse: 0 },
            { x: 0.5, y: 0.5, radius: 45, state: 'neutral', pulse: 0 },
            { x: 0.5, y: 0.75, radius: 45, state: 'neutral', pulse: 0 }
        ];

        const sentinels = [
            { id: 1, x: 80, y: 300, targetX: 80, targetY: 300, color: '#00f2ff', size: 18 }
        ];

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function update() {
            flux += 0.08;
            fluxEl.innerText = Math.floor(flux);

            sentinels.forEach(s => {
                const dx = s.targetX - s.x;
                const dy = s.targetY - s.y;
                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    s.x += dx * 0.07;
                    s.y += dy * 0.07;
                }

                // Node Alignment Logic
                nodes.forEach(n => {
                    const dist = Math.hypot(s.x - (n.x * canvas.width), s.y - (n.y * canvas.height));
                    if (dist < n.radius) n.state = 'aligned';
                });
            });

            // Pulse Animation
            nodes.forEach(n => {
                n.pulse += 0.05;
            });
        }

        function draw() {
            // Draw Grid Background
            ctx.fillStyle = '#0a0e14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#16212e';
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
            for(let j=0; j<canvas.height; j+=40) { ctx.beginPath(); ctx.moveTo(0,j); ctx.lineTo(canvas.width,j); ctx.stroke(); }

            // Draw Nodes
            nodes.forEach(n => {
                const nx = n.x * canvas.width;
                const ny = n.y * canvas.height;
                const pulseSize = n.radius + Math.sin(n.pulse) * 5;

                ctx.beginPath();
                ctx.arc(nx, ny, pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = n.state === 'aligned' ? '#00f2ff' : '#334155';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                if (n.state === 'aligned') {
                    ctx.fillStyle = 'rgba(0, 242, 255, 0.15)';
                    ctx.fill();
                }
            });

            // Draw Sentinels
            sentinels.forEach(s => {
                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = s.color;
                
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = s.color;
                ctx.fill();
                
                ctx.shadowBlur = 0; // Reset shadow

                if (activeSentinel === s) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        canvas.addEventListener('pointerdown', (e) => {
            const tapX = e.clientX;
            const tapY = e.clientY;
            
            // Check if tapping a Sentinel
            const clickedS = sentinels.find(s => Math.hypot(s.x - tapX, s.y - tapY) < 40);
            
            if (clickedS) {
                activeSentinel = clickedS;
            } else if (activeSentinel) {
                activeSentinel.targetX = tapX;
                activeSentinel.targetY = tapY;
            }
        });

        window.addEventListener('resize', init);
        init();
        loop();
    </script>
</body>
</html>

